{"totalCount":21,"grade":"F","repositories":[{"url":"https://github.com/MTES-MCT/docurba","grade":"F","alerts":[{"number":32,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/32","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/32","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/trames.js","start_line":165,"end_line":165,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/32/instances"},{"number":31,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/31","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/31","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/trames.js","start_line":155,"end_line":155,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/31/instances"},{"number":30,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/30","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/30","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/trames.js","start_line":140,"end_line":140,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/30/instances"},{"number":29,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/29","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/29","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/trames.js","start_line":35,"end_line":35,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/29/instances"},{"number":28,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/28","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/28","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/pipedrive.js","start_line":125,"end_line":125,"start_column":28,"end_column":31},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/28/instances"},{"number":27,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/27","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/27","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/georisques.js","start_line":46,"end_line":46,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/27/instances"},{"number":26,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/26","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/26","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/stack-trace-exposure","severity":"warning","description":"Information exposure through a stack trace","name":"js/stack-trace-exposure","tags":["external/cwe/cwe-209","external/cwe/cwe-497","security"],"full_description":"Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.","help":"# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    res.end(err.stack); // NOT OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\nInstead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:\n\n\n```javascript\nvar http = require('http');\n\nhttp.createServer(function onRequest(req, res) {\n  var body;\n  try {\n    body = handleRequest(req);\n  }\n  catch (err) {\n    res.statusCode = 500;\n    res.setHeader(\"Content-Type\", \"text/plain\");\n    log(\"Exception occurred\", err.stack);\n    res.end(\"An exception occurred\"); // OK\n    return;\n  }\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.setHeader(\"Content-Length\", body.length);\n  res.end(body);\n}).listen(3000);\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"This information exposed to the user depends on stack trace information."},"location":{"path":"server-middleware/geoide.js","start_line":42,"end_line":42,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/26/instances"},{"number":25,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/25","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/25","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/request-forgery","severity":"error","description":"Server-side request forgery","name":"js/request-forgery","tags":["external/cwe/cwe-918","security"],"full_description":"Making a network request with user-controlled data in the URL allows for request forgery attacks.","help":"# Server-side request forgery\nDirectly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.\n\n\n## Recommendation\nRestrict user inputs in the URL of an outgoing request, in particular:\n\n* Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.\n* Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal (\"`../`\") cannot be used to redirect the request to an unintended endpoint.\n\n## Example\nThe following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    // BAD: `target` is controlled by the attacker\n    http.get('https://' + target + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    let subdomain;\n    if (target === 'EU') {\n        subdomain = \"europe\"\n    } else {\n        subdomain = \"world\"\n    }\n\n    // GOOD: `subdomain` is controlled by the server\n    http.get('https://' + subdomain + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"The URL of this request depends on a user-provided value."},"location":{"path":"server-middleware/slack.js","start_line":211,"end_line":217,"start_column":9,"end_column":11},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/25/instances"},{"number":24,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/24","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/24","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/request-forgery","severity":"error","description":"Server-side request forgery","name":"js/request-forgery","tags":["external/cwe/cwe-918","security"],"full_description":"Making a network request with user-controlled data in the URL allows for request forgery attacks.","help":"# Server-side request forgery\nDirectly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.\n\n\n## Recommendation\nRestrict user inputs in the URL of an outgoing request, in particular:\n\n* Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.\n* Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal (\"`../`\") cannot be used to redirect the request to an unintended endpoint.\n\n## Example\nThe following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    // BAD: `target` is controlled by the attacker\n    http.get('https://' + target + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    let subdomain;\n    if (target === 'EU') {\n        subdomain = \"europe\"\n    } else {\n        subdomain = \"world\"\n    }\n\n    // GOOD: `subdomain` is controlled by the server\n    http.get('https://' + subdomain + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"The URL of this request depends on a user-provided value."},"location":{"path":"server-middleware/slack.js","start_line":155,"end_line":162,"start_column":5,"end_column":7},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/24/instances"},{"number":23,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/23","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/23","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/request-forgery","severity":"error","description":"Server-side request forgery","name":"js/request-forgery","tags":["external/cwe/cwe-918","security"],"full_description":"Making a network request with user-controlled data in the URL allows for request forgery attacks.","help":"# Server-side request forgery\nDirectly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.\n\n\n## Recommendation\nRestrict user inputs in the URL of an outgoing request, in particular:\n\n* Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.\n* Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal (\"`../`\") cannot be used to redirect the request to an unintended endpoint.\n\n## Example\nThe following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    // BAD: `target` is controlled by the attacker\n    http.get('https://' + target + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```javascript\nimport http from 'http';\n\nconst server = http.createServer(function(req, res) {\n    const target = new URL(req.url, \"http://example.com\").searchParams.get(\"target\");\n\n    let subdomain;\n    if (target === 'EU') {\n        subdomain = \"europe\"\n    } else {\n        subdomain = \"world\"\n    }\n\n    // GOOD: `subdomain` is controlled by the server\n    http.get('https://' + subdomain + \".example.com/data/\", res => {\n        // process request response ...\n    });\n\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"The URL of this request depends on a user-provided value."},"location":{"path":"server-middleware/modules/csw.js","start_line":145,"end_line":147,"start_column":30,"end_column":6},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/23/instances"},{"number":22,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/22","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/22","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/type-confusion-through-parameter-tampering","severity":"error","description":"Type confusion through parameter tampering","name":"js/type-confusion-through-parameter-tampering","tags":["external/cwe/cwe-843","security"],"full_description":"Sanitizing an HTTP request parameter may be ineffective if the user controls its type.","help":"# Type confusion through parameter tampering\nSanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.\n\nHowever, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.\n\n\n## Recommendation\nCheck the runtime type of sanitizer inputs if the input type is user-controlled.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\n\n## Example\nFor example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.\n\nIn the following example, a sanitizer checks that a path does not contain the `\"..\"` string, which would allow an attacker to access content outside a user-accessible directory.\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (file.indexOf(\"..\") !== -1) {\n    // BAD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\nAs written, this sanitizer is ineffective: an array like `[\"../\", \"/../secret.txt\"]` will bypass the sanitizer. The array does not contain `\"..\"` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `\"/secret.txt\"`. This happens since the concatenation of `\"/public/\"` and the array results in `\"/public/../,/../secret.txt\"`, which the `resolve`-call converts to `\"/secret.txt\"`.\n\nTo fix the sanitizer, check that the request parameter is a string, and not an array:\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (typeof file !== 'string' || file.indexOf(\"..\") !== -1) {\n    // GOOD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\n\n## References\n* Node.js API: [querystring](https://nodejs.org/api/querystring.html).\n* Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"Potential type confusion as this HTTP request parameter may be either an array or a string.\nPotential type confusion as this HTTP request parameter may be either an array or a string."},"location":{"path":"server-middleware/modules/geo.js","start_line":102,"end_line":102,"start_column":16,"end_column":38},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/22/instances"},{"number":21,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/21","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/21","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/type-confusion-through-parameter-tampering","severity":"error","description":"Type confusion through parameter tampering","name":"js/type-confusion-through-parameter-tampering","tags":["external/cwe/cwe-843","security"],"full_description":"Sanitizing an HTTP request parameter may be ineffective if the user controls its type.","help":"# Type confusion through parameter tampering\nSanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.\n\nHowever, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.\n\n\n## Recommendation\nCheck the runtime type of sanitizer inputs if the input type is user-controlled.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\n\n## Example\nFor example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.\n\nIn the following example, a sanitizer checks that a path does not contain the `\"..\"` string, which would allow an attacker to access content outside a user-accessible directory.\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (file.indexOf(\"..\") !== -1) {\n    // BAD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\nAs written, this sanitizer is ineffective: an array like `[\"../\", \"/../secret.txt\"]` will bypass the sanitizer. The array does not contain `\"..\"` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `\"/secret.txt\"`. This happens since the concatenation of `\"/public/\"` and the array results in `\"/public/../,/../secret.txt\"`, which the `resolve`-call converts to `\"/secret.txt\"`.\n\nTo fix the sanitizer, check that the request parameter is a string, and not an array:\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (typeof file !== 'string' || file.indexOf(\"..\") !== -1) {\n    // GOOD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\n\n## References\n* Node.js API: [querystring](https://nodejs.org/api/querystring.html).\n* Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"Potential type confusion as this HTTP request parameter may be either an array or a string.\nPotential type confusion as this HTTP request parameter may be either an array or a string."},"location":{"path":"server-middleware/modules/geo.js","start_line":63,"end_line":63,"start_column":16,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/21/instances"},{"number":20,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/20","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/20","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/type-confusion-through-parameter-tampering","severity":"error","description":"Type confusion through parameter tampering","name":"js/type-confusion-through-parameter-tampering","tags":["external/cwe/cwe-843","security"],"full_description":"Sanitizing an HTTP request parameter may be ineffective if the user controls its type.","help":"# Type confusion through parameter tampering\nSanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.\n\nHowever, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.\n\n\n## Recommendation\nCheck the runtime type of sanitizer inputs if the input type is user-controlled.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\n\n## Example\nFor example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.\n\nIn the following example, a sanitizer checks that a path does not contain the `\"..\"` string, which would allow an attacker to access content outside a user-accessible directory.\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (file.indexOf(\"..\") !== -1) {\n    // BAD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\nAs written, this sanitizer is ineffective: an array like `[\"../\", \"/../secret.txt\"]` will bypass the sanitizer. The array does not contain `\"..\"` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `\"/secret.txt\"`. This happens since the concatenation of `\"/public/\"` and the array results in `\"/public/../,/../secret.txt\"`, which the `resolve`-call converts to `\"/secret.txt\"`.\n\nTo fix the sanitizer, check that the request parameter is a string, and not an array:\n\n\n```javascript\nvar app = require(\"express\")(),\n  path = require(\"path\");\n\napp.get(\"/user-files\", function(req, res) {\n  var file = req.param(\"file\");\n  if (typeof file !== 'string' || file.indexOf(\"..\") !== -1) {\n    // GOOD\n    // we forbid relative paths that contain ..\n    // as these could leave the public directory\n    res.status(400).send(\"Bad request\");\n  } else {\n    var absolute = path.resolve(\"/public/\" + file);\n    console.log(\"Sending file: %s\", absolute);\n    res.sendFile(absolute);\n  }\n});\n\n```\n\n## References\n* Node.js API: [querystring](https://nodejs.org/api/querystring.html).\n* Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"Potential type confusion as this HTTP request parameter may be either an array or a string."},"location":{"path":"server-middleware/communes.js","start_line":21,"end_line":21,"start_column":31,"end_column":41},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/20/instances"},{"number":19,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/19","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/19","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/xss-through-exception","severity":"warning","description":"Exception text reinterpreted as HTML","name":"js/xss-through-exception","tags":["external/cwe/cwe-079","external/cwe/cwe-116","security"],"full_description":"Reinterpreting text from an exception as HTML can lead to a cross-site scripting vulnerability.","help":"# Exception text reinterpreted as HTML\nDirectly writing error messages to a webpage without sanitization allows for a cross-site scripting vulnerability if parts of the error message can be influenced by a user.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows an exception being written directly to the document, and this exception can potentially be influenced by the page URL, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    \n    try {\n        var parsed = unknownParseFunction(deflt); \n    } catch(e) {\n        document.write(\"Had an error: \" + e + \".\");\n    }\n}\n\n```\n\n## Example\nThis second example shows an input being validated using the JSON schema validator `ajv`, and in case of an error, the error message is sent directly back in the response.\n\n\n```javascript\nimport express from 'express';\nimport Ajv from 'ajv';\n\nlet app = express();\nlet ajv = new Ajv();\n\najv.addSchema({type: 'object', additionalProperties: {type: 'number'}}, 'pollData');\n\napp.post('/polldata', (req, res) => {\n    if (!ajv.validate('pollData', req.body)) {\n        res.send(ajv.errorsText());\n    }\n});\n\n```\nThis is unsafe, because the error message can contain parts of the input. For example, the input `{'<img src=x onerror=alert(1)>': 'foo'}` will generate the error `data/<img src=x onerror=alert(1)> should be number`, causing reflected XSS.\n\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"Exception text is reinterpreted as HTML without escaping meta-characters.\nException text is reinterpreted as HTML without escaping meta-characters."},"location":{"path":"server-middleware/trames.js","start_line":165,"end_line":165,"start_column":26,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/19/instances"},{"number":18,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/18","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/18","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/incomplete-url-substring-sanitization","severity":"warning","description":"Incomplete URL substring sanitization","name":"js/incomplete-url-substring-sanitization","tags":["correctness","external/cwe/cwe-020","security"],"full_description":"Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.","help":"# Incomplete URL substring sanitization\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param(\"url\");\n    // BAD: the host of `url` may be controlled by an attacker\n    if (url.includes(\"example.com\")) {\n        res.redirect(url);\n    }\n});\n\n```\nThe substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param(\"url\"),\n        host = urlLib.parse(url).host;\n    // BAD: the host of `url` may be controlled by an attacker\n    if (host.includes(\"example.com\")) {\n        res.redirect(url);\n    }\n});\n\n```\nThis is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param('url'),\n        host = urlLib.parse(url).host;\n    // GOOD: the host of `url` can not be controlled by an attacker\n    let allowedHosts = [\n        'example.com',\n        'beta.example.com',\n        'www.example.com'\n    ];\n    if (allowedHosts.includes(host)) {\n        res.redirect(url);\n    }\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"'incubateur.net' can be anywhere in the URL, and arbitrary hosts may come before or after it."},"location":{"path":"server-middleware/redirects.js","start_line":12,"end_line":12,"start_column":7,"end_column":46},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/18/instances"},{"number":17,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/17","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/17","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/incomplete-url-substring-sanitization","severity":"warning","description":"Incomplete URL substring sanitization","name":"js/incomplete-url-substring-sanitization","tags":["correctness","external/cwe/cwe-020","security"],"full_description":"Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.","help":"# Incomplete URL substring sanitization\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nHowever, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.\n\nEven if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.\n\n\n## Recommendation\nParse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param(\"url\");\n    // BAD: the host of `url` may be controlled by an attacker\n    if (url.includes(\"example.com\")) {\n        res.redirect(url);\n    }\n});\n\n```\nThe substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param(\"url\"),\n        host = urlLib.parse(url).host;\n    // BAD: the host of `url` may be controlled by an attacker\n    if (host.includes(\"example.com\")) {\n        res.redirect(url);\n    }\n});\n\n```\nThis is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:\n\n\n```javascript\napp.get('/some/path', function(req, res) {\n    let url = req.param('url'),\n        host = urlLib.parse(url).host;\n    // GOOD: the host of `url` can not be controlled by an attacker\n    let allowedHosts = [\n        'example.com',\n        'beta.example.com',\n        'www.example.com'\n    ];\n    if (allowedHosts.includes(host)) {\n        res.redirect(url);\n    }\n});\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"'https://docurba.beta.gouv.fr' may be followed by an arbitrary host name."},"location":{"path":"plugins/pdfMake.js","start_line":277,"end_line":277,"start_column":25,"end_column":85},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/17/instances"},{"number":16,"created_at":"2024-10-10T07:08:30Z","updated_at":"2024-10-10T07:08:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/16","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/16","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"js/server-side-unvalidated-url-redirection","severity":"warning","description":"Server-side URL redirect","name":"js/server-side-unvalidated-url-redirection","tags":["external/cwe/cwe-601","security"],"full_description":"Server-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.","help":"# Server-side URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```javascript\nconst app = require(\"express\")();\n\napp.get(\"/redirect\", function (req, res) {\n  // BAD: a request parameter is incorporated without validation into a URL redirect\n  res.redirect(req.query[\"target\"]);\n});\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```javascript\nconst app = require(\"express\")();\n\nconst VALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\";\n\napp.get(\"/redirect\", function (req, res) {\n  // GOOD: the request parameter is validated against a known fixed string\n  let target = req.query[\"target\"];\n  if (VALID_REDIRECT === target) {\n    res.redirect(target);\n  } else {\n    res.redirect(\"/\");\n  }\n});\n\n```\nAlternatively, we can check that the target URL does not redirect to a different host by parsing it relative to a base URL with a known host and verifying that the host stays the same:\n\n\n```javascript\nconst app = require(\"express\")();\n\nfunction isLocalUrl(path) {\n  try {\n    return (\n      // TODO: consider substituting your own domain for example.com\n      new URL(path, \"https://example.com\").origin === \"https://example.com\"\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\napp.get(\"/redirect\", function (req, res) {\n  // GOOD: check that we don't redirect to a different host\n  let target = req.query[\"target\"];\n  if (isLocalUrl(target)) {\n    res.redirect(target);\n  } else {\n    res.redirect(\"/\");\n  }\n});\n\n```\nNote that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:javascript-typescript\",\"language\":\"javascript-typescript\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:javascript-typescript","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"Untrusted URL redirection depends on a user-provided value."},"location":{"path":"server-middleware/redirects.js","start_line":13,"end_line":13,"start_column":23,"end_column":71},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/16/instances"},{"number":15,"created_at":"2024-08-29T13:43:06Z","updated_at":"2024-08-29T13:43:09Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/15","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/15","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5144","severity":"warning","description":"Server-side requests should not be vulnerable to forging attacks","name":"jssecurity:S5144","tags":["cwe"],"full_description":"Server-side requests should not be vulnerable to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to perform arbitrary requests on their behalf.<br></p>\n<p>An SSRF vulnerability can either be basic or blind, depending on whether the server’s fetched data is directly returned in the web application’s\nresponse.<br> The absence of the corresponding response for the coerced request on the application is not a barrier to exploitation and thus must be\ntreated in the same way as basic SSRF.</p>\n<h3>What is the potential impact?</h3>\n<p>SSRF usually results in unauthorized actions or data disclosure in the vulnerable application or on a different system it can reach. Conditional to\nwhat is reachable, remote command execution can be achieved, although it often requires chaining with further exploitations.</p>\n<p>Information disclosure is SSRF’s core outcome. Depending on the extracted data, an attacker can perform a variety of different actions that can\nrange from low to critical severity.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Local file read to host takeover</h4>\n<p>An attacker manipulates an application into performing a local request for a sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File\nURI scheme <code>file://</code>.<br> Once in possession of the SSH keys, the attacker establishes a remote connection to the system hosting the web\napplication.</p>\n<h4>Internal Network Reconnaissance</h4>\n<p>An attacker enumerates internal accessible ports from the affected server or others to which the server can communicate by iterating over the port\nfield in the URL <code>http://127.0.0.1:{port}</code>.<br> Taking advantage of other supported URL schemas (dependent on the affected system), for\nexample, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to connect to a database service and perform queries on it.</p>\n<h2>How to fix it in Node.js</h2>\n<h3>Code examples</h3>\n<p>The following code is vulnerable to SSRF as it opens a URL defined by untrusted data.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/example', async (req, res) =&gt; {\n    try {\n        await axios.get(req.query.url); // Noncompliant\n        res.send(\"OK\");\n    } catch (err) {\n        console.error(err);\n        res.send(\"ERROR\");\n    }\n})\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst schemesList = [\"http:\", \"https:\"];\nconst domainsList = [\"trusted1.example.com\", \"trusted2.example.com\"];\n\napp.get('/example', async (req, res) =&gt; {\n    const url = (new URL(req.query.url));\n\n    if (schemesList.includes(url.protocol) &amp;&amp; domainsList.includes(url.hostname)) {\n        try {\n            await axios.get(url);\n            res.send(\"OK\");\n        } catch (err) {\n            console.error(err);\n            res.send(\"ERROR\");\n        }\n    }else {\n        res.send(\"INVALID_URL\");\n    }\n})\n</pre>\n<h3>How does this work?</h3>\n<h4>Pre-Approved commands</h4>\n<p>Create a list of authorized and secure URLs that you want the application to be able to request.<br> If a user input does not match an entry in\nthis list, it should be rejected because it is considered unsafe.</p>\n<p><strong>Important note</strong>: The application must do validation on the server side. Not on client-side front-ends.</p>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the SSRF vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.commit.malicious.io</code>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\">Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/918\">CWE-918 - Server-Side Request Forgery (SSRF)</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222609\">Application Security and\n  Development: V-222609</a> - The application must not be subject to input handling vulnerabilities. </li>\n</ul>","security_severity_level":"medium"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"<!--SONAR_ISSUE_KEY:AZFwRM0ympEsyX1JFXKm-->Change this code to not construct the URL from user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AZFwRM0ympEsyX1JFXKm&open=AZFwRM0ympEsyX1JFXKm\">SonarCloud</a></p>"},"location":{"path":"server-middleware/georisques.js","start_line":35,"end_line":35,"start_column":28,"end_column":38},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/15/instances"},{"number":13,"created_at":"2024-03-05T13:33:31Z","updated_at":"2024-03-05T13:33:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/13","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/13","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5144","severity":"warning","description":"Server-side requests should not be vulnerable to forging attacks","name":"jssecurity:S5144","tags":["cwe"],"full_description":"Server-side requests should not be vulnerable to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to perform arbitrary requests on their behalf.<br></p>\n<p>An SSRF vulnerability can either be basic or blind, depending on whether the server’s fetched data is directly returned in the web application’s\nresponse.<br> The absence of the corresponding response for the coerced request on the application is not a barrier to exploitation and thus must be\ntreated in the same way as basic SSRF.</p>\n<h3>What is the potential impact?</h3>\n<p>SSRF usually results in unauthorized actions or data disclosure in the vulnerable application or on a different system it can reach. Conditional to\nwhat is reachable, remote command execution can be achieved, although it often requires chaining with further exploitations.</p>\n<p>Information disclosure is SSRF’s core outcome. Depending on the extracted data, an attacker can perform a variety of different actions that can\nrange from low to critical severity.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Local file read to host takeover</h4>\n<p>An attacker manipulates an application into performing a local request for a sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File\nURI scheme <code>file://</code>.<br> Once in possession of the SSH keys, the attacker establishes a remote connection to the system hosting the web\napplication.</p>\n<h4>Internal Network Reconnaissance</h4>\n<p>An attacker enumerates internal accessible ports from the affected server or others to which the server can communicate by iterating over the port\nfield in the URL <code>http://127.0.0.1:{port}</code>.<br> Taking advantage of other supported URL schemas (dependent on the affected system), for\nexample, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to connect to a database service and perform queries on it.</p>\n<h2>How to fix it in Node.js</h2>\n<h3>Code examples</h3>\n<p>The following code is vulnerable to SSRF as it opens a URL defined by untrusted data.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/example', async (req, res) =&gt; {\n    try {\n        await axios.get(req.query.url); // Noncompliant\n        res.send(\"OK\");\n    } catch (err) {\n        console.error(err);\n        res.send(\"ERROR\");\n    }\n})\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst schemesList = [\"http:\", \"https:\"];\nconst domainsList = [\"trusted1.example.com\", \"trusted2.example.com\"];\n\napp.get('/example', async (req, res) =&gt; {\n    const url = (new URL(req.query.url));\n\n    if (schemesList.includes(url.protocol) &amp;&amp; domainsList.includes(url.hostname)) {\n        try {\n            await axios.get(url);\n            res.send(\"OK\");\n        } catch (err) {\n            console.error(err);\n            res.send(\"ERROR\");\n        }\n    }else {\n        res.send(\"INVALID_URL\");\n    }\n})\n</pre>\n<h3>How does this work?</h3>\n<h4>Pre-Approved commands</h4>\n<p>Create a list of authorized and secure URLs that you want the application to be able to request.<br> If a user input does not match an entry in\nthis list, it should be rejected because it is considered unsafe.</p>\n<p><strong>Important note</strong>: The application must do validation on the server side. Not on client-side front-ends.</p>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the SSRF vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.commit.malicious.io</code>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\">Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/918\">CWE-918 - Server-Side Request Forgery (SSRF)</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222609\">Application Security and\n  Development: V-222609</a> - The application must not be subject to input handling vulnerabilities. </li>\n</ul>","security_severity_level":"medium"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"<!--SONAR_ISSUE_KEY:AY2OOeYMjxrwKZOyxVYl-->Change this code to not construct the URL from user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AY2OOeYMjxrwKZOyxVYl&open=AY2OOeYMjxrwKZOyxVYl\">SonarCloud</a></p>"},"location":{"path":"server-middleware/slack.js","start_line":211,"end_line":211,"start_column":9,"end_column":14},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/13/instances"},{"number":12,"created_at":"2024-03-05T13:33:31Z","updated_at":"2024-03-05T13:33:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/12","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/12","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5144","severity":"warning","description":"Server-side requests should not be vulnerable to forging attacks","name":"jssecurity:S5144","tags":["cwe"],"full_description":"Server-side requests should not be vulnerable to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to perform arbitrary requests on their behalf.<br></p>\n<p>An SSRF vulnerability can either be basic or blind, depending on whether the server’s fetched data is directly returned in the web application’s\nresponse.<br> The absence of the corresponding response for the coerced request on the application is not a barrier to exploitation and thus must be\ntreated in the same way as basic SSRF.</p>\n<h3>What is the potential impact?</h3>\n<p>SSRF usually results in unauthorized actions or data disclosure in the vulnerable application or on a different system it can reach. Conditional to\nwhat is reachable, remote command execution can be achieved, although it often requires chaining with further exploitations.</p>\n<p>Information disclosure is SSRF’s core outcome. Depending on the extracted data, an attacker can perform a variety of different actions that can\nrange from low to critical severity.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Local file read to host takeover</h4>\n<p>An attacker manipulates an application into performing a local request for a sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File\nURI scheme <code>file://</code>.<br> Once in possession of the SSH keys, the attacker establishes a remote connection to the system hosting the web\napplication.</p>\n<h4>Internal Network Reconnaissance</h4>\n<p>An attacker enumerates internal accessible ports from the affected server or others to which the server can communicate by iterating over the port\nfield in the URL <code>http://127.0.0.1:{port}</code>.<br> Taking advantage of other supported URL schemas (dependent on the affected system), for\nexample, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to connect to a database service and perform queries on it.</p>\n<h2>How to fix it in Node.js</h2>\n<h3>Code examples</h3>\n<p>The following code is vulnerable to SSRF as it opens a URL defined by untrusted data.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/example', async (req, res) =&gt; {\n    try {\n        await axios.get(req.query.url); // Noncompliant\n        res.send(\"OK\");\n    } catch (err) {\n        console.error(err);\n        res.send(\"ERROR\");\n    }\n})\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst schemesList = [\"http:\", \"https:\"];\nconst domainsList = [\"trusted1.example.com\", \"trusted2.example.com\"];\n\napp.get('/example', async (req, res) =&gt; {\n    const url = (new URL(req.query.url));\n\n    if (schemesList.includes(url.protocol) &amp;&amp; domainsList.includes(url.hostname)) {\n        try {\n            await axios.get(url);\n            res.send(\"OK\");\n        } catch (err) {\n            console.error(err);\n            res.send(\"ERROR\");\n        }\n    }else {\n        res.send(\"INVALID_URL\");\n    }\n})\n</pre>\n<h3>How does this work?</h3>\n<h4>Pre-Approved commands</h4>\n<p>Create a list of authorized and secure URLs that you want the application to be able to request.<br> If a user input does not match an entry in\nthis list, it should be rejected because it is considered unsafe.</p>\n<p><strong>Important note</strong>: The application must do validation on the server side. Not on client-side front-ends.</p>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the SSRF vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.commit.malicious.io</code>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\">Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/918\">CWE-918 - Server-Side Request Forgery (SSRF)</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222609\">Application Security and\n  Development: V-222609</a> - The application must not be subject to input handling vulnerabilities. </li>\n</ul>","security_severity_level":"medium"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"<!--SONAR_ISSUE_KEY:AY2OOeYMjxrwKZOyxVYk-->Change this code to not construct the URL from user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AY2OOeYMjxrwKZOyxVYk&open=AY2OOeYMjxrwKZOyxVYk\">SonarCloud</a></p>"},"location":{"path":"server-middleware/slack.js","start_line":155,"end_line":155,"start_column":5,"end_column":10},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/12/instances"},{"number":10,"created_at":"2024-03-05T13:33:31Z","updated_at":"2024-03-05T13:33:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/10","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/10","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5146","severity":"warning","description":"HTTP request redirections should not be open to forging attacks","name":"jssecurity:S5146","tags":["cwe"],"full_description":"HTTP request redirections should not be open to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Open redirection occurs when an application uses user-controllable data to redirect users to a URL.</p>\n<p>An attacker with malicious intent could manipulate a user to browse into a specially crafted URL, such as\n<code>https://trusted.example.com?url=evil.example.com</code>, to redirect the victim to his evil domain.</p>\n<p>Tricking users into sending the malicious HTTP request is usually the main task of exploiting an open redirection. Often, it requires an attacker\nto build a credible pretext to prevent suspicions from the victim.<br></p>\n<p>Attackers commonly use open redirect exploits in mass phishing campaigns.</p>\n<h3>What is the potential impact?</h3>\n<p>If an attacker tricks a user into opening a link of his choice, the user is redirected to a domain controlled by the attacker.</p>\n<p>From then on, the attacker can perform various malicious actions, some more impactful than others.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Domain Mirroring</h4>\n<p>A malicious link redirects to an attacker’s controlled website mirroring the interface of a web application trusted by the user. Due to the\nsimilarity in the application appearance and the apparently trustable clicked hyperlink, the user struggles to identify that they are browsing on a\nmalicious domain.<br></p>\n<p>Depending on the attacker’s purpose, the malicious website can leak credentials, bypass Multi-Factor Authentication (MFA), and reach any\nauthenticated data or action.</p>\n<h4>Malware Distribution</h4>\n<p>A malicious link redirects to an attacker’s controlled website that serves malware. On the same basis as the domain mirroring exploitation, the\nattacker develops a spearphishing or phishing campaign with a carefully crafted pretext that would result in the download and potential execution of a\nhosted malicious file.<br> The worst-case scenario could result in complete system compromise.</p>\n<h2>How to fix it in Express.js</h2>\n<h3>Code examples</h3>\n<p>The following noncompliant code example is vulnerable to open redirection as it constructs a URL with user-controllable data. This URL is then used\nto redirect the user without being first validated. An attacker can leverage this to manipulate users into performing unwanted redirects.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nserver.get('/redirect', (request, response) =&gt; {\n\n   response.redirect(request.query.url); // Noncompliant\n});\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nserver.get('/redirect', (request, response) =&gt; {\n\n   if (request.query.url.startsWith(\"https://www.example.com/\")) {\n      response.redirect(request.query.url);\n   }\n});\n</pre>\n<h3>How does this work?</h3>\n<p>Built-in framework methods should be preferred as, more often than not, these provide additional security mechanisms. Usually, these built-in\nmethods are engineered for internal page redirections. Thus, they might not be the solution for the reader’s use case.</p>\n<p>In case the application strictly requires external redirections based on user-controllable data, this could be done using the following\nalternatives:</p>\n<ol>\n  <li> Validating the <code>authority</code> part of the URL against a statically defined value (see Pitfalls). </li>\n  <li> Using an allow-list approach in case the destination URLs are multiple but limited. </li>\n  <li> Adding a customized page to which users are redirected, warning about the imminent action and requiring manual authorization to proceed. </li>\n</ol>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the Open Redirect vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.com.malicious.io</code>. The practice of taking over domains that maliciously look like\nexisting domains is widespread and is called <a href=\"https://en.wikipedia.org/wiki/Cybersquatting\">Cybersquatting</a>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/601\">CWE-601 - URL Redirection to Untrusted Site ('Open Redirect')</a> </li>\n</ul>","security_severity_level":"high"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"bba155c0d96467a88b54982aceb84dace479891f","message":{"text":"<!--SONAR_ISSUE_KEY:AY2OOeZPjxrwKZOyxVYo-->Change this code to not perform redirects based on user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AY2OOeZPjxrwKZOyxVYo&open=AY2OOeZPjxrwKZOyxVYo\">SonarCloud</a></p>"},"location":{"path":"server-middleware/redirects.js","start_line":13,"end_line":13,"start_column":9,"end_column":17},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/10/instances"}]}]}