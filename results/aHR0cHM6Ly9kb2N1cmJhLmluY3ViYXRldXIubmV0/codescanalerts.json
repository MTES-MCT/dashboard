{"totalCount":4,"grade":"D","repositories":[{"url":"https://github.com/MTES-MCT/docurba","grade":"D","alerts":[{"number":15,"created_at":"2024-08-29T13:43:06Z","updated_at":"2024-08-29T13:43:09Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/15","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/15","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5144","severity":"warning","description":"Server-side requests should not be vulnerable to forging attacks","name":"jssecurity:S5144","tags":["cwe"],"full_description":"Server-side requests should not be vulnerable to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to perform arbitrary requests on their behalf.<br></p>\n<p>An SSRF vulnerability can either be basic or blind, depending on whether the server’s fetched data is directly returned in the web application’s\nresponse.<br> The absence of the corresponding response for the coerced request on the application is not a barrier to exploitation and thus must be\ntreated in the same way as basic SSRF.</p>\n<h3>What is the potential impact?</h3>\n<p>SSRF usually results in unauthorized actions or data disclosure in the vulnerable application or on a different system it can reach. Conditional to\nwhat is reachable, remote command execution can be achieved, although it often requires chaining with further exploitations.</p>\n<p>Information disclosure is SSRF’s core outcome. Depending on the extracted data, an attacker can perform a variety of different actions that can\nrange from low to critical severity.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Local file read to host takeover</h4>\n<p>An attacker manipulates an application into performing a local request for a sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File\nURI scheme <code>file://</code>.<br> Once in possession of the SSH keys, the attacker establishes a remote connection to the system hosting the web\napplication.</p>\n<h4>Internal Network Reconnaissance</h4>\n<p>An attacker enumerates internal accessible ports from the affected server or others to which the server can communicate by iterating over the port\nfield in the URL <code>http://127.0.0.1:{port}</code>.<br> Taking advantage of other supported URL schemas (dependent on the affected system), for\nexample, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to connect to a database service and perform queries on it.</p>\n<h2>How to fix it in Node.js</h2>\n<h3>Code examples</h3>\n<p>The following code is vulnerable to SSRF as it opens a URL defined by untrusted data.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/example', async (req, res) =&gt; {\n    try {\n        await axios.get(req.query.url); // Noncompliant\n        res.send(\"OK\");\n    } catch (err) {\n        console.error(err);\n        res.send(\"ERROR\");\n    }\n})\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst schemesList = [\"http:\", \"https:\"];\nconst domainsList = [\"trusted1.example.com\", \"trusted2.example.com\"];\n\napp.get('/example', async (req, res) =&gt; {\n    const url = (new URL(req.query.url));\n\n    if (schemesList.includes(url.protocol) &amp;&amp; domainsList.includes(url.hostname)) {\n        try {\n            await axios.get(url);\n            res.send(\"OK\");\n        } catch (err) {\n            console.error(err);\n            res.send(\"ERROR\");\n        }\n    }else {\n        res.send(\"INVALID_URL\");\n    }\n})\n</pre>\n<h3>How does this work?</h3>\n<h4>Pre-Approved commands</h4>\n<p>Create a list of authorized and secure URLs that you want the application to be able to request.<br> If a user input does not match an entry in\nthis list, it should be rejected because it is considered unsafe.</p>\n<p><strong>Important note</strong>: The application must do validation on the server side. Not on client-side front-ends.</p>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the SSRF vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.commit.malicious.io</code>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\">Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/918\">CWE-918 - Server-Side Request Forgery (SSRF)</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222609\">Application Security and\n  Development: V-222609</a> - The application must not be subject to input handling vulnerabilities. </li>\n</ul>","security_severity_level":"medium"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"02777c0d543412e3678eea6786ba3c468dc7dbdb","message":{"text":"<!--SONAR_ISSUE_KEY:AZFwRM0ympEsyX1JFXKm-->Change this code to not construct the URL from user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AZFwRM0ympEsyX1JFXKm&open=AZFwRM0ympEsyX1JFXKm\">SonarCloud</a></p>"},"location":{"path":"server-middleware/georisques.js","start_line":35,"end_line":35,"start_column":28,"end_column":38},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/15/instances"},{"number":13,"created_at":"2024-03-05T13:33:31Z","updated_at":"2024-03-05T13:33:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/13","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/13","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5144","severity":"warning","description":"Server-side requests should not be vulnerable to forging attacks","name":"jssecurity:S5144","tags":["cwe"],"full_description":"Server-side requests should not be vulnerable to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to perform arbitrary requests on their behalf.<br></p>\n<p>An SSRF vulnerability can either be basic or blind, depending on whether the server’s fetched data is directly returned in the web application’s\nresponse.<br> The absence of the corresponding response for the coerced request on the application is not a barrier to exploitation and thus must be\ntreated in the same way as basic SSRF.</p>\n<h3>What is the potential impact?</h3>\n<p>SSRF usually results in unauthorized actions or data disclosure in the vulnerable application or on a different system it can reach. Conditional to\nwhat is reachable, remote command execution can be achieved, although it often requires chaining with further exploitations.</p>\n<p>Information disclosure is SSRF’s core outcome. Depending on the extracted data, an attacker can perform a variety of different actions that can\nrange from low to critical severity.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Local file read to host takeover</h4>\n<p>An attacker manipulates an application into performing a local request for a sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File\nURI scheme <code>file://</code>.<br> Once in possession of the SSH keys, the attacker establishes a remote connection to the system hosting the web\napplication.</p>\n<h4>Internal Network Reconnaissance</h4>\n<p>An attacker enumerates internal accessible ports from the affected server or others to which the server can communicate by iterating over the port\nfield in the URL <code>http://127.0.0.1:{port}</code>.<br> Taking advantage of other supported URL schemas (dependent on the affected system), for\nexample, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to connect to a database service and perform queries on it.</p>\n<h2>How to fix it in Node.js</h2>\n<h3>Code examples</h3>\n<p>The following code is vulnerable to SSRF as it opens a URL defined by untrusted data.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/example', async (req, res) =&gt; {\n    try {\n        await axios.get(req.query.url); // Noncompliant\n        res.send(\"OK\");\n    } catch (err) {\n        console.error(err);\n        res.send(\"ERROR\");\n    }\n})\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst schemesList = [\"http:\", \"https:\"];\nconst domainsList = [\"trusted1.example.com\", \"trusted2.example.com\"];\n\napp.get('/example', async (req, res) =&gt; {\n    const url = (new URL(req.query.url));\n\n    if (schemesList.includes(url.protocol) &amp;&amp; domainsList.includes(url.hostname)) {\n        try {\n            await axios.get(url);\n            res.send(\"OK\");\n        } catch (err) {\n            console.error(err);\n            res.send(\"ERROR\");\n        }\n    }else {\n        res.send(\"INVALID_URL\");\n    }\n})\n</pre>\n<h3>How does this work?</h3>\n<h4>Pre-Approved commands</h4>\n<p>Create a list of authorized and secure URLs that you want the application to be able to request.<br> If a user input does not match an entry in\nthis list, it should be rejected because it is considered unsafe.</p>\n<p><strong>Important note</strong>: The application must do validation on the server side. Not on client-side front-ends.</p>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the SSRF vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.commit.malicious.io</code>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\">Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/918\">CWE-918 - Server-Side Request Forgery (SSRF)</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222609\">Application Security and\n  Development: V-222609</a> - The application must not be subject to input handling vulnerabilities. </li>\n</ul>","security_severity_level":"medium"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"02777c0d543412e3678eea6786ba3c468dc7dbdb","message":{"text":"<!--SONAR_ISSUE_KEY:AY2OOeYMjxrwKZOyxVYl-->Change this code to not construct the URL from user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AY2OOeYMjxrwKZOyxVYl&open=AY2OOeYMjxrwKZOyxVYl\">SonarCloud</a></p>"},"location":{"path":"server-middleware/slack.js","start_line":139,"end_line":139,"start_column":9,"end_column":14},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/13/instances"},{"number":12,"created_at":"2024-03-05T13:33:31Z","updated_at":"2024-03-05T13:33:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/12","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/12","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5144","severity":"warning","description":"Server-side requests should not be vulnerable to forging attacks","name":"jssecurity:S5144","tags":["cwe"],"full_description":"Server-side requests should not be vulnerable to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to perform arbitrary requests on their behalf.<br></p>\n<p>An SSRF vulnerability can either be basic or blind, depending on whether the server’s fetched data is directly returned in the web application’s\nresponse.<br> The absence of the corresponding response for the coerced request on the application is not a barrier to exploitation and thus must be\ntreated in the same way as basic SSRF.</p>\n<h3>What is the potential impact?</h3>\n<p>SSRF usually results in unauthorized actions or data disclosure in the vulnerable application or on a different system it can reach. Conditional to\nwhat is reachable, remote command execution can be achieved, although it often requires chaining with further exploitations.</p>\n<p>Information disclosure is SSRF’s core outcome. Depending on the extracted data, an attacker can perform a variety of different actions that can\nrange from low to critical severity.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Local file read to host takeover</h4>\n<p>An attacker manipulates an application into performing a local request for a sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File\nURI scheme <code>file://</code>.<br> Once in possession of the SSH keys, the attacker establishes a remote connection to the system hosting the web\napplication.</p>\n<h4>Internal Network Reconnaissance</h4>\n<p>An attacker enumerates internal accessible ports from the affected server or others to which the server can communicate by iterating over the port\nfield in the URL <code>http://127.0.0.1:{port}</code>.<br> Taking advantage of other supported URL schemas (dependent on the affected system), for\nexample, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to connect to a database service and perform queries on it.</p>\n<h2>How to fix it in Node.js</h2>\n<h3>Code examples</h3>\n<p>The following code is vulnerable to SSRF as it opens a URL defined by untrusted data.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/example', async (req, res) =&gt; {\n    try {\n        await axios.get(req.query.url); // Noncompliant\n        res.send(\"OK\");\n    } catch (err) {\n        console.error(err);\n        res.send(\"ERROR\");\n    }\n})\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nconst axios = require('axios');\nconst express = require('express');\n\nconst schemesList = [\"http:\", \"https:\"];\nconst domainsList = [\"trusted1.example.com\", \"trusted2.example.com\"];\n\napp.get('/example', async (req, res) =&gt; {\n    const url = (new URL(req.query.url));\n\n    if (schemesList.includes(url.protocol) &amp;&amp; domainsList.includes(url.hostname)) {\n        try {\n            await axios.get(url);\n            res.send(\"OK\");\n        } catch (err) {\n            console.error(err);\n            res.send(\"ERROR\");\n        }\n    }else {\n        res.send(\"INVALID_URL\");\n    }\n})\n</pre>\n<h3>How does this work?</h3>\n<h4>Pre-Approved commands</h4>\n<p>Create a list of authorized and secure URLs that you want the application to be able to request.<br> If a user input does not match an entry in\nthis list, it should be rejected because it is considered unsafe.</p>\n<p><strong>Important note</strong>: The application must do validation on the server side. Not on client-side front-ends.</p>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the SSRF vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.commit.malicious.io</code>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\">Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF)</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/918\">CWE-918 - Server-Side Request Forgery (SSRF)</a> </li>\n  <li> STIG Viewer - <a href=\"https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222609\">Application Security and\n  Development: V-222609</a> - The application must not be subject to input handling vulnerabilities. </li>\n</ul>","security_severity_level":"medium"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"02777c0d543412e3678eea6786ba3c468dc7dbdb","message":{"text":"<!--SONAR_ISSUE_KEY:AY2OOeYMjxrwKZOyxVYk-->Change this code to not construct the URL from user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AY2OOeYMjxrwKZOyxVYk&open=AY2OOeYMjxrwKZOyxVYk\">SonarCloud</a></p>"},"location":{"path":"server-middleware/slack.js","start_line":86,"end_line":86,"start_column":5,"end_column":10},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/12/instances"},{"number":10,"created_at":"2024-03-05T13:33:31Z","updated_at":"2024-03-05T13:33:32Z","url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/10","html_url":"https://github.com/MTES-MCT/Docurba/security/code-scanning/10","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"jssecurity:S5146","severity":"warning","description":"HTTP request redirections should not be open to forging attacks","name":"jssecurity:S5146","tags":["cwe"],"full_description":"HTTP request redirections should not be open to forging attacks","help":"<h2>Why is this an issue?</h2>\n<p>Open redirection occurs when an application uses user-controllable data to redirect users to a URL.</p>\n<p>An attacker with malicious intent could manipulate a user to browse into a specially crafted URL, such as\n<code>https://trusted.example.com?url=evil.example.com</code>, to redirect the victim to his evil domain.</p>\n<p>Tricking users into sending the malicious HTTP request is usually the main task of exploiting an open redirection. Often, it requires an attacker\nto build a credible pretext to prevent suspicions from the victim.<br></p>\n<p>Attackers commonly use open redirect exploits in mass phishing campaigns.</p>\n<h3>What is the potential impact?</h3>\n<p>If an attacker tricks a user into opening a link of his choice, the user is redirected to a domain controlled by the attacker.</p>\n<p>From then on, the attacker can perform various malicious actions, some more impactful than others.</p>\n<p>Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.</p>\n<h4>Domain Mirroring</h4>\n<p>A malicious link redirects to an attacker’s controlled website mirroring the interface of a web application trusted by the user. Due to the\nsimilarity in the application appearance and the apparently trustable clicked hyperlink, the user struggles to identify that they are browsing on a\nmalicious domain.<br></p>\n<p>Depending on the attacker’s purpose, the malicious website can leak credentials, bypass Multi-Factor Authentication (MFA), and reach any\nauthenticated data or action.</p>\n<h4>Malware Distribution</h4>\n<p>A malicious link redirects to an attacker’s controlled website that serves malware. On the same basis as the domain mirroring exploitation, the\nattacker develops a spearphishing or phishing campaign with a carefully crafted pretext that would result in the download and potential execution of a\nhosted malicious file.<br> The worst-case scenario could result in complete system compromise.</p>\n<h2>How to fix it in Express.js</h2>\n<h3>Code examples</h3>\n<p>The following noncompliant code example is vulnerable to open redirection as it constructs a URL with user-controllable data. This URL is then used\nto redirect the user without being first validated. An attacker can leverage this to manipulate users into performing unwanted redirects.</p>\n<h4>Noncompliant code example</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"noncompliant\">\nserver.get('/redirect', (request, response) =&gt; {\n\n   response.redirect(request.query.url); // Noncompliant\n});\n</pre>\n<h4>Compliant solution</h4>\n<pre data-diff-id=\"1\" data-diff-type=\"compliant\">\nserver.get('/redirect', (request, response) =&gt; {\n\n   if (request.query.url.startsWith(\"https://www.example.com/\")) {\n      response.redirect(request.query.url);\n   }\n});\n</pre>\n<h3>How does this work?</h3>\n<p>Built-in framework methods should be preferred as, more often than not, these provide additional security mechanisms. Usually, these built-in\nmethods are engineered for internal page redirections. Thus, they might not be the solution for the reader’s use case.</p>\n<p>In case the application strictly requires external redirections based on user-controllable data, this could be done using the following\nalternatives:</p>\n<ol>\n  <li> Validating the <code>authority</code> part of the URL against a statically defined value (see Pitfalls). </li>\n  <li> Using an allow-list approach in case the destination URLs are multiple but limited. </li>\n  <li> Adding a customized page to which users are redirected, warning about the imminent action and requiring manual authorization to proceed. </li>\n</ol>\n<h3>Pitfalls</h3>\n<h4>The trap of 'StartsWith' and equivalents</h4>\n<p>When validating untrusted URLs by checking if they start with a trusted scheme and authority pair <code>scheme://authority</code>, <strong>ensure\nthat the validation string contains a path separator <code>/</code> as the last character</strong>.<br></p>\n<p>If the validation string does not contain a terminating path separator, the Open Redirect vulnerability remains; only the exploitation technique\nchanges.</p>\n<p>Thus, a validation like <code>startsWith(\"https://example.com\")</code> or an equivalent with the regex <code>^https://example\\.com.*</code> can be\nexploited with the following URL <code>https://example.com.malicious.io</code>. The practice of taking over domains that maliciously look like\nexisting domains is widespread and is called <a href=\"https://en.wikipedia.org/wiki/Cybersquatting\">Cybersquatting</a>.</p>\n<h2>Resources</h2>\n<h3>Standards</h3>\n<ul>\n  <li> OWASP - <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">Top 10 2021 Category A1 - Broken Access Control</a> </li>\n  <li> OWASP - <a href=\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\">Top 10 2017 Category A5 - Broken Access Control</a>\n  </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/20\">CWE-20 - Improper Input Validation</a> </li>\n  <li> CWE - <a href=\"https://cwe.mitre.org/data/definitions/601\">CWE-601 - URL Redirection to Untrusted Site ('Open Redirect')</a> </li>\n</ul>","security_severity_level":"high"},"tool":{"name":"SonarCloud","guid":null,"version":null},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"(default)","environment":"{}","category":"","state":"open","commit_sha":"02777c0d543412e3678eea6786ba3c468dc7dbdb","message":{"text":"<!--SONAR_ISSUE_KEY:AY2OOeZPjxrwKZOyxVYo-->Change this code to not perform redirects based on user-controlled data. <p>See more on <a href=\"https://sonarcloud.io/project/issues?id=MTES-MCT_Docurba&issues=AY2OOeZPjxrwKZOyxVYo&open=AY2OOeZPjxrwKZOyxVYo\">SonarCloud</a></p>"},"location":{"path":"server-middleware/redirects.js","start_line":13,"end_line":13,"start_column":9,"end_column":17},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/Docurba/code-scanning/alerts/10/instances"}]}]}