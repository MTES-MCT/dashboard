{"totalCount":1,"grade":"F","repositories":[{"url":"https://github.com/MTES-MCT/aides-territoires","grade":"F","alerts":[{"number":49,"created_at":"2023-12-24T12:52:08Z","updated_at":"2024-10-10T07:04:19Z","url":"https://api.github.com/repos/MTES-MCT/aides-territoires/code-scanning/alerts/49","html_url":"https://github.com/MTES-MCT/aides-territoires/security/code-scanning/49","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"py/url-redirection","severity":"error","description":"URL redirection from remote source","name":"py/url-redirection","tags":["external/cwe/cwe-601","security"],"full_description":"URL redirection based on unvalidated user input may cause redirection to malicious web sites.","help":"# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\nIf this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL does not include an explicit host name.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```python\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    return redirect(target, code=302)\n\n```\nIf you know the set of valid redirect targets, you can maintain a list of them on the server and check that the user input is in that list:\n\n\n```python\nfrom flask import Flask, request, redirect\n\nVALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\"\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    if target == VALID_REDIRECT:\n        return redirect(target, code=302)\n    else:\n        # ignore the target and redirect to the home page\n        return redirect('/', code=302)\n\n```\nOften this is not possible, so an alternative is to check that the target URL does not specify an explicit host name. For example, you can use the `urlparse` function from the Python standard library to parse the URL and check that the `netloc` attribute is empty.\n\nNote, however, that some cases are not handled as we desire out-of-the-box by `urlparse`, so we need to adjust two things, as shown in the example below:\n\n* Many browsers accept backslash characters (`\\`) as equivalent to forward slash characters (`/`) in URLs, but the `urlparse` function does not.\n* Mistyped URLs such as `https:/example.com` or `https:///example.com` are parsed as having an empty `netloc` attribute, while browsers will still redirect to the correct site.\n\n```python\nfrom flask import Flask, request, redirect\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    target = request.args.get('target', '')\n    target = target.replace('\\\\', '')\n    if not urlparse(target).netloc and not urlparse(target).scheme:\n        # relative path, safe to redirect\n        return redirect(target, code=302)\n    # ignore the target and redirect to the home page\n    return redirect('/', code=302)\n\n```\nFor Django application, you can use the function `url_has_allowed_host_and_scheme` to check that a URL is safe to redirect to, as shown in the following example:\n\n\n```python\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.views import View\n\nclass RedirectView(View):\n    def get(self, request, *args, **kwargs):\n        target = request.GET.get('target', '')\n        if url_has_allowed_host_and_scheme(target, allowed_hosts=None):\n            return HttpResponseRedirect(target)\n        else:\n            # ignore the target and redirect to the home page\n            return redirect('/')\n```\nNote that `url_has_allowed_host_and_scheme` handles backslashes correctly, so no additional processing is required.\n\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Python standard library: [ urllib.parse](https://docs.python.org/3/library/urllib.parse.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n","security_severity_level":"medium"},"tool":{"name":"CodeQL","guid":null,"version":"2.19.2"},"most_recent_instance":{"ref":"refs/heads/master","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:python\",\"language\":\"python\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:python","state":"open","commit_sha":"eae9cab6581d465f89e36d318db1b584bac2e123","message":{"text":"Untrusted URL redirection depends on a user-provided value."},"location":{"path":"src/core/utils.py","start_line":208,"end_line":208,"start_column":16,"end_column":51},"classifications":[]},"instances_url":"https://api.github.com/repos/MTES-MCT/aides-territoires/code-scanning/alerts/49/instances"}]}]}